#!/usr/bin/env python3

'''This scripts tests the various forms of the junior editor caption.'''

import argparse, configparser, os, os.path, re, subprocess, sys
from datetime import datetime

script = os.path.basename(__file__)
progdir = os.path.dirname(os.path.realpath(__file__))
workdir = os.path.join(progdir, '../data')

def mylog(a):
  print(script + ': ' + a, flush = True)
  
def myproc(b, internal = True):
  if internal:
    if args.dryrun: b.insert(2, '-n')
    mylog(f'executing \'{" ".join(b)}\' ...')
    subprocess.Popen(b).communicate()
  else:
    mylog(f'executing \'{" ".join(b)}\' ...')
    if not args.dryrun:
      subprocess.Popen(b).communicate()

mylog(f'start time: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}')

## parse command line
parser = argparse.ArgumentParser(description = 'generate tex and pdf files from junioreditor-template.tex and some ini file')
parser.add_argument(
  'vars',
  nargs = '*',
  help = 'Sections of config.ini to process. Without arguments, all sections are processed.'
)
parser.add_argument(
  '-c',
  '--config',
  default = 'USenglish',
  help = "Configuration file basename. The default is 'USenglish'."
)
parser.add_argument(
  '-k',
  '--keep',
  action = 'store_true',
  help = 'preserve temporary files'
)
parser.add_argument(
  '-p',
  '--purge',
  action = 'store_true',
  help = 'delete the class file and others'
)
parser.add_argument(
  '-s',
  '--sub',
  default = 'junioreditor',
  help = "Subdirectory of the data directory. The default is 'junioreditor'."
)
parser.add_argument(
  '-t',
  '--template',
  default = 'junioreditor-template.tex',
  help = "Template file. The default is 'junioreditor-template.tex'."
)
parser.add_argument(
  '-n',
  '--dryrun',
  action = 'store_true',
  help = 'only pretend to execute all the work'
)
args = parser.parse_args()
#mylog(f"options are {args}")

## parse configuration file 
os.chdir(workdir)
mylog(f"descending into subdirectory '{args.sub}' ...")
os.chdir(args.sub)
config = configparser.ConfigParser()
config.read_file(open(args.config + '.ini'))
content = open(args.template).read()

if len(args.vars) > 0:
  mysections = []
  for v in args.vars:
    if v in config.sections():
      mysections.append(v)
    else:
      mylog(f"ignoring '{v}' as it is not a section name")
  mysections = list(set(mysections))
  if len(mysections) > 0:
    mylog(f'{len(mysections)} of {len(config.sections())} possible sections chosen')
  else:
    mylog(f'no sections chosen, nothing to do')
    sys.exit(0)
else:
  mysections = config.sections()
  mylog(f'processing all sections as no command line arguments are present')

## remove old temporary files
myproc(['python3', os.path.join(progdir, 'tidy-up.py'), '--pdf', '--tex', '-s', args.sub])

# remove old result
fnresult = '01_result_' + args.config + '.pdf'
if os.path.exists(fnresult):
  mylog(f"deleting '{fnresult}' ...")
  if not args.dryrun:
    os.remove(fnresult) 

## copy cls files
myproc(['python3', os.path.join(progdir, 'copy-cls-files.py'), '-s', args.sub])

## generate tex and pdf files
#
# pdftk is not installed by default, but is freely available for Linux, macOS and Windows:
# pdftk test-*.pdf cat output 01_result.pdf
#
# ghostscript most likely works on Linux and macOS:
# gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=01_result.pdf test-*.pdf
#
# On macOS the following preinstalled python script should work, too:
# "/System/Library/Automator/Combine PDF Pages.action/Contents/Resources/join.py" -o 01_result.pdf test-*.pdf
#
cmd = ['pdftk',]      
for s in mysections:
  mylog(f'processing section {s}')
  fnbase = f'autogenerated-{args.config}-{s}'
  fntex = fnbase + '.tex'
  copy = content
  with open(fntex, 'w') as out:
    cs = config[s]
    for a in cs:
#      mylog(f'replacing {a.upper()} with {cs[a]}')
      copy = re.sub(a.upper(), cs[a], copy)
    mylog(f'writing output to {fntex}')
    out.write(copy)
  for cmd1 in ('pdflatex', 'bibtex', 'pdflatex', 'pdflatex'):
    myproc([cmd1 , fnbase], internal = False)
  myproc(['pdftk' , fnbase + '.pdf', 'burst', 'output', fnbase + '_%03d.pdf'], internal = False)  
  cmd.append(fnbase + '_002.pdf')

## produce final pdf file
mylog(f'merging relevant pages into {fnresult}')
cmd.extend(['cat', 'output', fnresult])    
myproc(cmd, internal = False)

## tidy up directory
if not args.keep:
  cmd1 = ['python3', os.path.join(progdir, 'tidy-up.py'), '--pdf', '--tex', '-s', args.sub]
  if args.purge: cmd1.insert(2, '-p')
  myproc(cmd1)

mylog(f'end time: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}')

#input('Press RETURN to proceed!') 
