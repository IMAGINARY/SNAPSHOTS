#!/usr/bin/env python3

'''This scripts tests the various forms of the junior editor caption.
It assumes pdftk to be installed and tidy-up.py to be in the search path.
It runs on Ubuntu 20.04 and will certainly need adaptions to run on
Windows or macoS.'''

import argparse, configparser, os, os.path, platform, re, subprocess, sys
  
## parse command line
parser = argparse.ArgumentParser(description = '''
generate tex and pdf files from junioreditor-template.tex and some ini file''')
parser.add_argument(
  'vars',
  nargs = '*',
  help = 'Sections of config.ini to process. Without arguments, all sections are processed.'
)
parser.add_argument(
  '-c',
  '--config',
  default = 'config',
  help = 'configuration file basename, the default is config'
)
parser.add_argument(
  '-k',
  '--keep',
  action = 'store_true',
  help = 'preserve temporary files'
)
parser.add_argument(
'-w',
'--workdir',
default = '../data/junioreditor',
help = 'working directory relative to program directory, the default is ../data/junioreditor'
)
args = parser.parse_args()
progdir = os.path.dirname(os.path.realpath(__file__))
workdir = os.path.join(progdir, args.workdir)

## parse configuration file 
os.chdir(workdir)
config = configparser.ConfigParser()
config.read_file(open(args.config + '.ini'))
qt = open('junioreditor-template.tex')
content = qt.read()

if len(args.vars) > 0:
  mysections = []
  for v in args.vars:
    if v in config.sections():
      mysections.append(v)
    else:
      print(f"ignoring '{v}' as it is not a section name")
  mysections = list(set(mysections))
  if len(mysections) > 0:
    print(f'{len(mysections)} of {len(config.sections())} possible sections chosen')
  else:
    print('no sections chosen, nothing to do')
    sys.exit(0)
else:
  mysections = config.sections()
  print('processing all sections as no command line arguments are present')

# delete old result
fnresult = '01_result_' + args.config + '.pdf'
if os.path.exists(fnresult):
  os.remove(fnresult) 

## generate tex and pdf files
cmd = ['pdftk',]      
for s in mysections:
  print(f'\nprocessing section {s}')
  fnbase = f'autogenerated-{args.config}-{s}'
  fntex = fnbase + '.tex'
  copy = content
  with open(fntex, 'w') as out:
    cs = config[s]
    for a in cs:
      print(f'  replacing {a.upper()} with {cs[a]}')
      copy = re.sub(a.upper(), cs[a], copy)
    print(f'  writing output to {fntex}')
    out.write(copy)
  for cmd1 in ('pdflatex', 'bibtex', 'pdflatex', 'pdflatex'):
    subprocess.Popen([cmd1 , fnbase]).communicate()
  subprocess.Popen(['pdftk' , fnbase + '.pdf', 'burst', 'output', fnbase + '_%03d.pdf']).communicate()  
  cmd.append(fnbase + '_002.pdf')

## produce final pdf file
print(f'merging relevant pages into {fnresult}')
cmd.extend(['cat', 'output', fnresult])    
p = subprocess.Popen(cmd)
p.communicate()

## tidy up directory
if not args.keep:
  p = subprocess.Popen(['python3', os.path.join(progdir, 'tidy-up.py'), '--pdf', '--tex']).communicate()
